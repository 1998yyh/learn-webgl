## 1.html
实施光照的方式有很多种，最简单的可能就是方向光源了。

方向光是指光照均匀地来自某一个方向，晴朗天气下的太阳经常被当作方向光源， 它距离太远所以光线被看作是平行的照到地面上。

计算方向光非常简单，将方向光的方向和面的朝向点乘就可以得到两个方向的余弦值。

点乘在几何意义上称之为投影

我们可以将颜色值和点乘的结果相乘， 然后就有光了


## 2.html

如果你旋转了 F 就会发现，F 虽然旋转了但是光照没变， 我们希望随着 F 的旋转正面总是被照亮的。

为了解决这个问题就需要在物体重定向时重定向法向量， 和位置一样我们也可以将向量和矩阵相乘，这个矩阵显然是 world 矩阵， 现在我们只传了一个矩阵 u_matrix，所以先来改成传递两个矩阵， 一个叫做 u_world 的世界矩阵，另一个叫做 u_worldViewProjection 也就是我们现在的 u_matrix。


## 3.html

这里有一个问题我不知道如何表述所以就用图解展示。 我们用 normal 和 u_world 相乘去重定向法向量， 如果世界矩阵被缩放了怎么办？事实是会得到错误的法向量。

我从没想弄清为什么，但解决办法就是对世界矩阵求逆并转置， 用这个矩阵就会得到正确的结果。

在图解里中间的 紫色球体是未缩放的， 左边的红色球体用的世界矩阵并缩放了， 你可以看出有些不太对劲。右边蓝色 的球体用的是世界矩阵求逆并转置后的矩阵。

点击图解循环观察不同的表示形式，你会发现在缩放严重时左边的（世界矩阵） 法向量和表面没有保持垂直关系，而右边的（世界矩阵求逆并转置） 一直保持垂直。最后一种模式是将它们渲染成红色，你会发现两个球体的光照结果相差非常大， 基于可视化的结果可以得出使用世界矩阵求逆转置是对的。

修改代码让示例使用这种矩阵，首先更新着色器，理论上我们可以直接更新 u_world 的值，但是最好将它重命名以表示它真正的含义，防止混淆。


## 4.html 点光源

不知道为啥 我的点光源是黑色的

``` js
// 设置使用的颜色
gl.uniform4fv(u_color, [0.2, 1, 0.2, 1]); // green
// 设置灯管位置
// 这个地方设置出错了
gl.uniform3fv(u_lightWorldPosition, [20, 30, 60]);
// 旧版本的
gl.uniform3fv(u_reverseLightDirection, m4.normalize([20, 30, 60]));
```

## 5.html 点光源 正常版本

## 6.html

现在我们可以加一个叫做镜面高光的东西。

观察现实世界中的物体，如果物体表面恰好将光线反射到你眼前， 就会显得非常明亮，像镜子一样。

我们可以通过计算光线是否反射到眼前来模拟这种情况，点乘又一次起到了至关重要的作用。

如何测试呢？如果入射角和反射角恰好与眼睛和和光源的夹角相同，那么光线就会反射到眼前。


如果我们知道了物体表面到光源的方向（刚刚已经计算过了）， 加上物体表面到视区/眼睛/相机的方向，再除以 2 得到 halfVector 向量，

将这个向量和法向量比较，如果方向一致，那么光线就会被反射到眼前。 那么如何确定方向是否一致呢？用之前的点乘就可以了。1 表示相符， 0 表示垂直，-1 表示相反。



## 7.html

但是亮瞎了。

我们可以将点乘结果进行求幂运算来解决太亮的问题， 它会把高光从线性变换变成指数变换。